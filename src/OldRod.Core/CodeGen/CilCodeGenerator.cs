using System;
using System.Collections.Generic;
using System.Linq;
using AsmResolver.Net.Cil;
using AsmResolver.Net.Cts;
using AsmResolver.Net.Signatures;
using OldRod.Core.Ast.Cil;
using Rivers;
using Rivers.Analysis;

namespace OldRod.Core.CodeGen
{
    public class CilCodeGenerator : ICilAstVisitor<IList<CilInstruction>>
    {
        private const string InvalidAstMessage =
            "The provided CIL AST is invalid or incomplete. " +
            "This might be because the IL to CIL recompiler contains a bug. " +
            "For more details, inspect the control flow graphs generated by the recompiler.";

        private readonly CilAstFormatter _formatter;
        private readonly CodeGenerationContext _context;

        public CilCodeGenerator(CodeGenerationContext context)
        {
            _context = context ?? throw new ArgumentNullException(nameof(context));
            _formatter = new CilAstFormatter(context.MethodBody);
        }
        
        public IList<CilInstruction> VisitCompilationUnit(CilCompilationUnit unit)
        {
            var result = new List<CilInstruction>();

            // Define block headers to use as branch targets later.
            foreach (var node in unit.ControlFlowGraph.Nodes)
                _context.BlockHeaders[node] = CilInstruction.Create(CilOpCodes.Nop);

            // Traverse all blocks in an order that keeps dominance in mind.
            // This way, the resulting code has a more natural structure rather than
            // a somewhat arbitrary order of blocks. 
            
            var dominatorInfo = new DominatorInfo(unit.ControlFlowGraph.Entrypoint);
            var dominatorTree = dominatorInfo.ToDominatorTree();
            
            var stack = new Stack<Node>();
            stack.Push(dominatorTree.Nodes[unit.ControlFlowGraph.Entrypoint.Name]);
            
            while (stack.Count > 0)
            {
                var treeNode = stack.Pop();
                var cfgNode = unit.ControlFlowGraph.Nodes[treeNode.Name];
                var block = (CilAstBlock) cfgNode.UserData[CilAstBlock.AstBlockProperty];
                
                // Add instructions of current block to result.
                result.AddRange(block.AcceptVisitor(this));
                
                // Move on to child nodes.
                var directChildren = new HashSet<Node>();
                foreach (var outgoing in treeNode.OutgoingEdges)
                {
                    var outgoingTarget = outgoing.Target;
                    if (cfgNode.GetSuccessors().All(x => x.Name != outgoingTarget.Name))
                        stack.Push(outgoingTarget);
                    else
                        directChildren.Add(outgoingTarget);
                }

                foreach (var child in directChildren)
                    stack.Push(child);
            }

            return result;
        }

        public IList<CilInstruction> VisitBlock(CilAstBlock block)
        {
            var result = new List<CilInstruction>();
            result.Add(block.BlockHeader);
            foreach (var statement in block.Statements)
                result.AddRange(statement.AcceptVisitor(this));
            return result;
        }

        public IList<CilInstruction> VisitExpressionStatement(CilExpressionStatement statement)
        {
            return statement.Expression.AcceptVisitor(this);
        }

        public IList<CilInstruction> VisitInstructionExpression(CilInstructionExpression expression)
        {
            var result = new List<CilInstruction>();
            var instruction = new CilInstruction(0, expression.OpCode, expression.Operand);

            AssertInstructionValidity(expression, instruction);

            if (expression.ShouldEmitFlagsUpdate)
            {
                result.AddRange(_context.BuildBinaryExpression(
                    expression.Arguments[0].AcceptVisitor(this),
                    expression.Arguments[1].AcceptVisitor(this),
                    new[] {CilInstruction.Create(CilOpCodes.Sub)},
                    _context.Constants.GetFlagMask(expression.AffectedFlags)));
            }
            else
            {
                foreach (var argument in expression.Arguments)
                    result.AddRange(argument.AcceptVisitor(this));
                result.Add(instruction);
            }

            if (expression.Operand is VariableSignature variable && !_context.Variables.Contains(variable))
                _context.Variables.Add(variable);
            

            return result;
        }

        private void AssertInstructionValidity(CilInstructionExpression expression, CilInstruction instruction)
        {
            if (instruction.GetStackPopCount(_context.MethodBody) != expression.Arguments.Count)
            {
                throw new CilCodeGeneratorException(InvalidAstMessage, new ArgumentException(
                    $"The number of arguments is invalid for the expression '{expression.AcceptVisitor(_formatter)}'."));
            }

            switch (expression.OpCode.OperandType)
            {
                case CilOperandType.ShortInlineBrTarget:
                case CilOperandType.InlineBrTarget:
                    if (!(expression.Operand is CilInstruction))
                    {
                        throw new CilCodeGeneratorException(InvalidAstMessage, new ArgumentException(
                            $"Expected a branch target operand in '{expression.AcceptVisitor(_formatter)}'."));
                    }

                    break;
                case CilOperandType.InlineMethod:
                case CilOperandType.InlineField:
                case CilOperandType.InlineType:
                case CilOperandType.InlineTok:
                    if (!(expression.Operand is IMemberReference))
                    {
                        throw new CilCodeGeneratorException(InvalidAstMessage, new ArgumentException(
                            $"Expected a member reference operand in '{expression.AcceptVisitor(_formatter)}'."));
                    }

                    break;
                case CilOperandType.InlineSig:
                    if (!(expression.Operand is StandAloneSignature))
                    {
                        throw new CilCodeGeneratorException(InvalidAstMessage, new ArgumentException(
                            $"Expected a signature operand in '{expression.AcceptVisitor(_formatter)}'."));
                    }

                    break;
                case CilOperandType.InlineI:
                    if (!(expression.Operand is int))
                    {
                        throw new CilCodeGeneratorException(InvalidAstMessage, new ArgumentException(
                            $"Expected an int32 operand in '{expression.AcceptVisitor(_formatter)}'."));
                    }

                    break;
                case CilOperandType.InlineI8:
                    if (!(expression.Operand is long))
                    {
                        throw new CilCodeGeneratorException(InvalidAstMessage, new ArgumentException(
                            $"Expected an int64 operand in '{expression.AcceptVisitor(_formatter)}'."));
                    }

                    break;
                case CilOperandType.InlineNone:
                    if (expression.Operand != null)
                    {
                        throw new CilCodeGeneratorException(InvalidAstMessage, new ArgumentException(
                            $"Unexpected operand in '{expression.AcceptVisitor(_formatter)}'."));
                    }

                    break;

                case CilOperandType.InlineR:
                    if (!(expression.Operand is double))
                    {
                        throw new CilCodeGeneratorException(InvalidAstMessage, new ArgumentException(
                            $"Expected a float64 operand in '{expression.AcceptVisitor(_formatter)}'."));
                    }

                    break;
                case CilOperandType.ShortInlineI:
                    if (!(expression.Operand is sbyte))
                    {
                        throw new CilCodeGeneratorException(InvalidAstMessage, new ArgumentException(
                            $"Expected an int8 operand in '{expression.AcceptVisitor(_formatter)}'."));
                    }

                    break;
                case CilOperandType.ShortInlineR:
                    if (!(expression.Operand is float))
                    {
                        throw new CilCodeGeneratorException(InvalidAstMessage, new ArgumentException(
                            $"Expected a float32 operand in '{expression.AcceptVisitor(_formatter)}'."));
                    }

                    break;
                case CilOperandType.InlineString:
                    if (!(expression.Operand is string))
                    {
                        throw new CilCodeGeneratorException(InvalidAstMessage, new ArgumentException(
                            $"Expected a string operand in '{expression.AcceptVisitor(_formatter)}'."));
                    }

                    break;
                case CilOperandType.InlineSwitch:
                    if (!(expression.Operand is IList<CilInstruction>))
                    {
                        throw new CilCodeGeneratorException(InvalidAstMessage, new ArgumentException(
                            $"Expected a switch table operand in '{expression.AcceptVisitor(_formatter)}'."));
                    }

                    break;

                case CilOperandType.ShortInlineVar:
                case CilOperandType.InlineVar:
                    if (!(expression.Operand is VariableSignature))
                    {
                        throw new CilCodeGeneratorException(InvalidAstMessage, new ArgumentException(
                            $"Expected a variable operand in '{expression.AcceptVisitor(_formatter)}'."));
                    }

                    break;
                case CilOperandType.InlineArgument:
                case CilOperandType.ShortInlineArgument:
                    if (!(expression.Operand is ParameterSignature))
                    {
                        throw new CilCodeGeneratorException(InvalidAstMessage, new ArgumentException(
                            $"Expected a parameter operand in '{expression.AcceptVisitor(_formatter)}'."));
                    }

                    break;
                
                default:
                    throw new CilCodeGeneratorException(InvalidAstMessage, new ArgumentException(
                        $"Unexpected opcode in '{expression.AcceptVisitor(_formatter)}'."));
            }
        }
    }
}